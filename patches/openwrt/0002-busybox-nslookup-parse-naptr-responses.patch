diff --git a/package/utils/busybox/patches/999-0001-nslookup-parse-naptr-responses.patch b/package/utils/busybox/patches/999-0001-nslookup-parse-naptr-responses.patch
new file mode 100644
index 0000000000..ffc608ca20
--- /dev/null
+++ b/package/utils/busybox/patches/999-0001-nslookup-parse-naptr-responses.patch
@@ -0,0 +1,164 @@
+From 63e6e64b39ce8d4789397266391fa3822f79e7c5 Mon Sep 17 00:00:00 2001
+From: Arien Judge <arien.judge@morsemicro.com>
+Date: Mon, 4 Aug 2025 00:26:25 +1000
+Subject: [PATCH] nslookup: parse naptr responses
+
+To enable a lightweight openroaming deployment, add parsing of NAPTR
+query responses.
+
+Following the style of the existing file, a "light touch" has been
+taken to implementing NAPTR parsing, intentionally not creating
+additional variables and instead walking the response message to
+handle variable length character strings.
+
+Dynamically checking rdlen against input length bytes to ensure
+the parser does not dump contents outside of memory bounds.
+
+As per RFC-2915 a NAPTR RR is as follows:
+
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                     ORDER                     |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    |                   PREFERENCE                  |
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                     FLAGS                     /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                    SERVICES                   /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                    REGEXP                     /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+    /                  REPLACEMENT                  /
+    /                                               /
+    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
+
+where:
+
+ORDER           A 16-bit unsigned integer specifying the order in which
+                the NAPTR records MUST be processed to ensure correct
+                ordering of rules.
+
+PREFERENCE      A 16-bit unsigned integer that specifies the order in
+                which NAPTR records with equal "order" values SHOULD be
+                processed.
+
+FLAGS           A <character-string> containing flags to control
+                aspects of the rewriting and interpretation of the
+                fields in the record.
+
+SERVICES        A <character-string> specifying the service(s)
+                available down this rewrite path. It may also specify
+                the particular protocol that is used to talk with a
+                service.
+
+REGEXP          A <character-string> containing a substitution
+                expression that is applied to the original string held
+                by the client in order to construct the next domain
+                name to lookup.
+
+REPLACEMENT     A <domain-name> containing the next NAME to query for
+                NAPTR, SRV, or address records depending on the value
+                of the flags field.
+
+[1] https://datatracker.ietf.org/doc/html/rfc2915
+
+Signed-off-by: Arien Judge <arien.judge@morsemicro.com>
+---
+ networking/nslookup.c | 68 ++++++++++++++++++++++++++++++++++++++++++-
+ 1 file changed, 67 insertions(+), 1 deletion(-)
+
+diff --git a/networking/nslookup.c b/networking/nslookup.c
+index 6da97baf4..a01ff85f4 100644
+--- a/networking/nslookup.c
++++ b/networking/nslookup.c
+@@ -25,7 +25,7 @@
+ //usage:#define nslookup_full_usage "\n\n"
+ //usage:       "Query DNS about HOST"
+ //usage:       IF_FEATURE_NSLOOKUP_BIG("\n")
+-//usage:       IF_FEATURE_NSLOOKUP_BIG("\nQUERY_TYPE: soa,ns,a,"IF_FEATURE_IPV6("aaaa,")"cname,mx,txt,ptr,srv,any")
++//usage:       IF_FEATURE_NSLOOKUP_BIG("\nQUERY_TYPE: soa,ns,a,"IF_FEATURE_IPV6("aaaa,")"cname,mx,txt,ptr,srv,any,naptr")
+ //usage:#define nslookup_example_usage
+ //usage:       "$ nslookup localhost\n"
+ //usage:       "Server:     default\n"
+@@ -286,6 +286,7 @@ static const struct {
+ 	{ ns_t_srv,   "SRV"   },
+ 	{ ns_t_ptr,   "PTR"   },
+ 	{ ns_t_any,   "ANY"   },
++	{ ns_t_naptr, "NAPTR" },
+ };
+ 
+ static const char *const rcodes[] ALIGN_PTR = {
+@@ -501,6 +502,71 @@ static NOINLINE int parse_reply(const unsigned char *msg, size_t len)
+ 			printf("\tminimum = %lu\n", ns_get32(cp));
+ 			break;
+ 
++		case ns_t_naptr:
++			if (rdlen < 7) {
++				//printf("NAPTR record too short\n");
++				return -1;
++			}
++
++			cp = ns_rr_rdata(rr);
++
++			printf("%s\tnaptr = %u %u", ns_rr_name(rr),
++				ns_get16(cp), ns_get16(cp + 2));
++
++			rdlen -= 4;
++			cp = cp + 4;
++
++			/*
++			 * FLAGS - character string
++			 * n - length byte
++			 * cp + 1 - start of character string
++			 */
++			n = *cp;
++			if (rdlen < n + 1) {
++				//printf("malformed record\n");
++				return -1;
++			}
++			printf(" \"%.*s\"", n, cp + 1);
++			rdlen -= n;
++			cp = cp + 1 + n;
++
++			/*
++			 * SERVICES - character string
++			 * n - length byte
++			 * cp + 1 - start of character string
++			 */
++			n = *cp;
++			if (rdlen < n + 1) {
++				//printf("malformed record\n");
++				return -1;
++			}
++			printf(" \"%.*s\"", n, cp + 1);
++			rdlen -= n;
++			cp = cp + 1 + n;
++
++			/*
++			 * REGEXP - character string
++			 * n - length byte
++			 * cp + 1 - start of character string
++			 */
++			n = *cp;
++			if (rdlen < n) {
++				//printf("malformed record\n");
++				return -1;
++			}
++			printf(" \"%.*s\"", n, cp + 1);
++			cp = cp + 1 + n;
++
++			/* REPLACEMENT - domain name */
++			n = ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
++			                       cp, dname, sizeof(dname));
++			if (n < 0) {
++				//printf("Unable to uncompress domain: %s\n", strerror(errno));
++				return -1;
++			}
++			printf(" %s\n", dname);
++			break;
++
+ 		default:
+ 			break;
+ 		}
+-- 
+2.25.1
+
